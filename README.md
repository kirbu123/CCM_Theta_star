# virtual-husky

Данный репозиторий посвящен реализации виртуального Husky в симуляторе [Isaac Sim](https://docs.omniverse.nvidia.com/isaacsim/latest/index.html), а также запуска различных сценариев и записи синтетических датасетов на их основе.

![virtual-husky](img/husky_code_u.png)

## Table of Contents
- [virtual-husky](#virtual-husky)
  - [Table of Contents](#table-of-contents)
  - [Introduction](#introduction)
  - [Pre-requisites or Dependencies](#pre-requisites-or-dependencies)
    - [Isaac Sim Installation](#isaac-sim-installation)
    - [ROS2 Humble Installation](#ros2-humble-installation)
    - [DVC Installation and Setup](#dvc-installation-and-setup)
  - [Structure](#structure)
  - [Quickstart](#quickstart)
  - [Usage scenarios](#usage-scenarios)
    - [Работа с ROS2](#работа-с-ros2)
  - [Configuration](#configuration)
  - [Data (and dvc)](#data-and-dvc)
    - [3D модель робота](#3d-модель-робота)
    - [3D модель среды](#3d-модель-среды)
    - [DVC 'на пальцах'](#dvc-на-пальцах)
    - [Работа с DVC](#работа-с-dvc)
  - [TODO](#todo)

## Pre-requisites or Dependencies

- [Isaac Sim](https://docs.omniverse.nvidia.com/isaacsim/latest/install_workstation.html)
- [ROS2-Humble](https://docs.ros.org/en/humble/Installation.html)
- [DVC](https://dvc.org/doc/install)

### Isaac Sim Installation
На данный момент предполагается работа с desktop-версией симулятора, работа в докер контейнере и без графического интерфейса также поддерживается, но будет добавлена позже.

В целом, [официальная инструкция](https://docs.omniverse.nvidia.com/isaacsim/latest/install_workstation.html) содержит довольно детальное описание всех шагов установки, которым нужно внимательно следовать и не пропускать "лишние шаги" если не уверены что они действительно лишние. Здесь приведены только некоторые замечания к этой инструкции.

**Notes:**
- Системные требования
    - Системные требования указанные в п.1 инструкции являются скорее рекомендациями, симулятор успешно (хоть и более медленно) работает и на менее мощном железе.
    - Если у вас меньше оперативной памяти чем "минимально необходимо", рекомендуется увеличить размер файла подкачки (swap file) до соответствия требованиям или чуть больше (например у вас 16 Gb RAM, минимальное требование 32 Gb RAM - [создать swap file](https://www.digitalocean.com/community/tutorials/how-to-add-swap-space-on-ubuntu-20-04) 16+ Gb).
    - **Критичное требование** к видеокарте - она должна поддерживать технологию RTX.
- Регистрация и установка
    - Для регистрации как nvidia developer лучше использовать почту в домене gmail.com (есть подозрение, что с российскими адресами не работает принципиально)
    - Для скачивания и установки Isaac Sim потребуется VPN, желательно платный тк объем данных большой. Далее при использовании через python API VPN не нужен, но при использовании GUI симулятор с завидной регулярностью просит авторизоваться на сайте Nvidia, что опять таки требует VPN.
    - П. 6 инструкции по установке VSCode - разумеется, не является обязательным. Это может быть удобно, так как многие утилиты содержат специальную кнопку для "открыть код в VSCode" и даже поддерживается отладка, но на практике если ваш компьютер не соответствует "оптимальным" требованиям, то такой функционал будет работать очень медленно.

### ROS2 Humble Installation

В целом критичным является именно ROS2, и скорее всего с Foxy также будет работать, но конечная цель все равно Humble и рекомендуется использовать именно его.

Для установки - следуем [официальной документации](https://docs.ros.org/en/humble/Installation.html).

Если у вас Ubuntu 20.04 - возможно, проще использовать Docker контейнер, так как без него придётся [собирать Humble из исходников](https://docs.ros.org/en/humble/Installation/Alternatives/Ubuntu-Development-Setup.html).


### DVC Installation and Setup
DVC - это инструмент для управления данными, который позволяет хранить данные в удаленном хранилище (в данном случае - S3-совместимом удалённом хранилище), версионировать их и работать с ними как с локальными. **По сути - "git for data".** Подробнее о том, зачем это нужно и как работать с DVC можно прочитать в разделе [Data (and dvc)](#data-and-dvc).

С установкой dvc всё просто - установка согласно инструкции на [официальном сайте](https://dvc.org/doc/install), а для работы с удаленным хранилищем необходимо установить следующие переменные среды:

```bash
export AWS_SECRET_ACCESS_KEY=jyk6lgkvhwuemj752vawtcnvw2afz2pwac6skzhsrcs3rfxvbgpru
export AWS_ACCESS_KEY_ID=jvn4b7kof64vmlbur7i3ahx6wblq
```

(Да это секретные ключи, но хранилище бесплатное, репозиторий приватный и надеюсь все будет хорошо, если есть конструктивные предложения по улучшению - буду рад услышать и поправить).

Как работать с DVC описано в разделе [Data (and dvc)](#data-and-dvc), но чтение [официального гайда](https://dvc.org/doc/start/data-and-model-versioning) также приветствуется.

## Structure
Структура репозитория:
```bash
virtual-husky
├── assets
│   └── husky
│       ├── ####.usd
│       ├── ####.usd
│       └── ####.usd
├── assets.dvc
├── config
│   ├── general
│   │   └── ####.yaml
│   └── LiDAR
│       ├── Example_Rotary.json
│       └── VLP_16.json
├── gripper_control.py
├── img
│   └── husky_code_u.png
├── navi_pick_cams.py
├── navi_pick.py
├── README.md
└── src
    ├── config.py
    ├── controllers
    │   ├── interface_helper.py
    │   ├── kinematics.py
    │   ├── motion_policy_interface.py
    │   ├── pick_place.py
    │   └── rmpflow.py
    ├── rmpflow
    │   ├── ####.urdf
    │   ├── ####.yaml
    │   ├── ####.yaml
    │   ├── ####.urdf
    │   ├── ####.usd
    │   └── ####.usd
    ├── sensors
    │   ├── cameras.py
    │   ├── imu.py
    │   ├── lidar.py
    │   └── tf.py
    └── tasks
        ├── follow_target.py
        ├── navigation.py
        └── pick_place.py
```

где:
- `assets` - директория, в которой хранятся различные 3D модели (или их составляющие), как правило в формате usd. Для экономии места используется бинарный формат usd, и эта директория версионируется с помощью dvc, а не git.

- `config` - папка с конфигурационными файлами сценариев в целом и отдельных сенсоров.

- `navi_pick.py` - скрипт для запуска сценария навигации и захвата цели (в демо-среде, без сенсоров).

- `navi_pick_cams.py` - скрипт для запуска сценария навигации и захвата цели (в демо-среде "склад", c сенсорами  и публикацией в ROS).

- `src/{controllers,rmpflow,tasks}` - содержат скрипты отвечающие за управление и кинематику робота, пока более детально только в документации.

- `src/sensors` - содержит скрипты для настройки сенсоров и публикации данных в ROS2.

- `navi_pick.py` - скрипт для запуска сценария навигации и захвата цели (в демо-среде, без сенсоров).

- `navi_pick_cams.py` - скрипт для запуска сценария навигации и захвата цели (в демо-среде, c сенсорами).

## Quickstart

Запустим тестовый сценарий навигации и захвата цели (в демо-среде, без сенсоров).

**Notes:** 
- Для корректной работы скриптов (импорт модулей Isaac Sim и тд) - необходимо запускать их из директории расположенной где-либо внутри корневой директории симулятора (при установке по умолчанию - `/home/<USER>/.local/share/ov/pkg/isaac_sim-2022.2.1`).

В целом можно располагать скрипты прямо в ней, но разработчики предусмотрели отдельную директорию для хранения пользовательских расширений (и скриптов соответственно) - `extension_examples/user_examples` и логично использовать её. Или по крайней мере просто внутри директории `extension_examples`.

*SubNote:* extension_examles - просто ссылка на директорию, которая лежит глубже, поэтому относительные пути могут отличаться от просто `extension_examples/bla-blah`- это нормально.

- Скрипты запускаются не просто через `python`, a из корневой директории симулятора, через `./python.sh <path_to_script.py>`. Это необходимо для корректной работы импорта модулей Isaac Sim.

- Если у вас установлен ROS2/ROS его **не надо включать (source ...)** в терминале, который используется для запуска скриптов. Это приведет к конфликтам переменных среды.

- Для корректной работы с ROS(2) также необходимо настроить переменные среды, подробнее в разделе [Работа с ROS2](#работа-с-ros2).



```bash
# Переходим в корневую директорию симулятора и далее в `extension_examples`
# Не забываем заменить <USER> на свой логин
cd /home/<USER>/.local/share/ov/pkg/isaac_sim-2022.2.1/extension_examples

# Клонируем репозиторий
git clone https://git.sberrobots.ru/mipt.navigation/simulator/virtual-husky.git
# или если у вас есть ssh ключи
git clone git@git.sberrobots.ru:mipt.navigation/simulator/virtual-husky.git

# Переходим в директорию с репозиторием
cd virtual-husky

# Подтягиваем данные
dvc pull

# Выходим обратно в корневую директорию симулятора
cd ../..

# Запускаем скрипт
./python.sh extension_examples/virtual-husky/navi_pick.py

# Ждём пока скрипт загрузится и начнёт выполняться, это может занять время (до 5-7 минут)

# Для остановки скрипта нажимаем Ctrl+C
```

## Usage scenarios

Пока только тестовый - подъехать к кубику и поднять его. По сути описан в [Quickstart](#quickstart).

В ближайшее время планируется добавить возможность управления с клавиатуры для записи тестового датасета.

### Работа с ROS2

To be filled


## Configuration

To be filled

## Data (and dvc)

На данный момент данны состоят из фотореалистичной сцены 5го этажа МФТИ и 3D модели самого робота.
В будущем также появятся 3D элементы сцены, которые можно будет размещать в среде.

### 3D модель робота

3D модель робота хранится (по частям) при помощи dvc в разделе assets. Эти части можно открывать в Isaac Sim, модифицировать и коммитить изменения в репозиторий, поддерживая консистентность кода и 3D модели.

На данный момент части всего 2:
- `husky.usd` - колёсная платформа Husky, включает в себя колёса, подвеску и корпус.
    - `husky_with_sensors.usd` - то же самое, но с сенсорами (камерами и лидаром)
- `ur5_with_gripper.usd` - робот-манипулятор UR5 с гриппером.
    - *(пока нет)* `ur5_with_gripper_and_cam.usd` - то же самое, но с камерой

### 3D модель среды

Модель фотореалистичная, весит ~1Gb, а S3 хранилище используется бесплатное, поэтому на данный момент хранится только на яндекс диске. 

Кроме того она пока не редактируется и версионировать там +- нечего. В будущем, когда появится полноценное S3 хранилище - под контроль dvc включим также и её.

### DVC 'на пальцах'

DVC - своеобразный git для (больших) файлов и файлов которые хранятся в бинарном виде и не могут корректно отслеживаться при помощи git.

Принцип работы очень простой - дял каждого файла/директории, которую добавили для отслеживания - dvc вычисляет хэш-сумму и сохраняет её в специальный файл `.dvc` вместо самого файла. При этом сам файл не добавляется в git (добавляется в .`gitignore`), а вместо него добавляется файл `.dvc` (который весит килобайты, вместо мега- и гигабайтов).

Также в директории `.dvc` хранится конфигурация самого dvc (в том числе и ссылка на удалённое хранилище). Таким образом, когда вы делаете `git push` - хэш-суммы файлов релевантные этому коммиту сохраняются в репозитории, вместе с информацией об удалённом хранилище, где они лежат.

И когда вы/ваш коллега на другом устройстве сделает `git pull` - он подгрузит всю необходимую информацию. И останется только сделать `dvc pull` чтобы подтянуть данные с удаленного хранилища.

### Работа с DVC

По большей части работа с dvc аналогична работе с git, и по сути дублирует её:

- **git**
    - `git init` - инициализировать репозиторий git
    - `git add <file>` - добавить файл под управление git
    - `git commit` - закоммитить изменения
    - `git push` - отправить изменения на удалённый репозиторий
    - `git pull` - подтянуть изменения с удалённого репозитория
    - `git checkout <branch>` - переключиться на ветку
- **dvc**
    - `dvc init` - инициализировать репозиторий dvc
    - `dvc add <file>` - добавить файл под управление dvc
    - `dvc commit` - **не существует**, коммиты делаются через git
    - `dvc push` - отправить изменения на удалённое хранилище
    - `dvc pull` - подтянуть изменения с удалённого хранилища
    - `dvc checkout <branch>` - переключиться на ветку

Таким образом приблизительный сценарий использования такой:
1. Обновили скрипт/написали новый: `git add <scripts/my_script.py>`
2. Если ваш скрипт использует новые данные (**или вы обновили существующую модель**) - добавляем их под управление/отмечаем изменения в dvc: `dvc add <data/my_data.usd>`
3. Git commit: `git commit -m "Added my_script.py"`
4. Git push: `git push`
5. Dvc push: `dvc push`
6. Готово, вы восхитительны!

Создание новой ветки и переключение на неё происходит аналогично git:
1. `git checkout -b <new_branch>`
2. `dvc checkout <new_branch>` (опять же уже без `-b`, тк dvc следит за ветками git)

Note: !Важно! Если добавили новую модель - сначала добавляем ее под dvc (`dvc add`), код и её git (`git add ...`). Чтобы dvc добавил её в `.gitignore` и не было пробелем с коммитомю

В основном так, но ознакомление с официальной [документацией](https://dvc.org/doc/start/data-management/data-versioning) приветствуется.
Туда же стоит обращаться если у вас есть сомнения как работает тот или иной механизм, dvc это классно и удобно, но есть нюансы и **аналогия с git не идеальна**. Если вы не уверены  - лучше посмотреть в документацию.

## TODO

